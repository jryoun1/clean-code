# 1장 깨끗한 코드



## 나쁜 코드

책에서는 좋은 코드가 중요하다라는 것을 전제에 기반한다.    

그렇다면 여기서 좋은 코드는 무엇이고, 나쁜 코드는 무엇일까? 

정확한 정의는 나오지 않지만 책에서 주어진 예시와 내용들을 토대로 생각해보면 다음과 같이 정의할 수 있을 것 같다. 

`나쁜 코드` 

- 가독성이 좋지 못하다
- 코드 수정 시 다른 곳에서 문제가 발생한다
- 코드 수정을 위해서 여러 곳을 수정해야한다
- 코드 작성자 이외에는 읽기도 수정하기도 어렵다

`르블랑의 법칙` : **나중은 결코 오지 않는다.** 나중에 손보겠다고 한 코드 + 돌아간다는 사실에 안도감을 느끼며 위로함 => 결국 고치지 않는다. 

우리는 르블랑의 법칙을 생각하고 처음부터 깨끗한 코드를 작성하려고 노력해야한다. 



그렇다면 나쁜 코드를 작성하게되는 나름 우리들의 합리적인 핑계는 무엇일까?

- 기존의 설계를 뒤집는 방향으로의 요구사항 변경
- 일정이 촉박하여 제대로 설계를 할 시간이 부족
- 빠르게 끝내고 퇴근하고 싶은 마음



위와 같은 핑계들이 있을 수 있지만 실제로 나쁜 코드를 작성하는 것에 대한 책임은 위와 같은 원인들이 아니라 **프로그래머**에게 있다.

기한을 맞추려면 나쁜 코드를 양산할 수 밖에 없다고 말하는 것은 틀렸다. 오히려 엉망진창인 상태로 인해서 속도가 늦어지게 되므로 기한을 맞추는 방법은 바로 **언제나 코드를 최대한 깨끗하게 유지하는 습관**이다. 



## 깨끗한 코드

그렇다면 깨끗한 코드, 도대체 그게 무엇일까?

책에서는 깨끗한 코드를 작성하기 위해서는 '청결' 이라는 힘겹게 습득한 감각을 활용해 자잘한 기법들을 적용하는 절제와 규율이 필요하다고 말한다. 이때 열쇠는 '코드 감각'이다. 코드 감각이 있다면 좋은 코드와 나쁜 코드를 구분할 수 있고, 또한 절제와 규율을 적용해 나쁜 코드를 좋은 코드로 바꾸는 전략도 파악할 수 있다. 

즉, 코드감각이라는 것은 타고난 사람도 있을 수 있고 그렇지 않은 사람도 있으므로 노력하고 많이 경험해서 이를 알아내야 얻어낼 수 있도록 해야한다.



**비야네 스트롭스트롭 (C++ 창시자)**

- 깨끗한 코드는 보기에 즐거운 코드
- 효율 (속도 뿐만 아니라 CPU 자원들의 활용까지도 포함)
- 철저한 오류처리 (e.g. 메모리 누수, 경쟁 상태, 일관성 업슨 명명법)
- 깨끗한 코드는 한 가지를 잘 한다 (SRP를 의미하는 것 같다)



**그래디 부치 (Object Oriented Analysis and Design with Application 저자)**

- 깨끗한 코드는 단순하고 직접적 => **가독성**이 중요
- 설계자의 의도를 숨기지 않고, 오히려 명쾌한 추상화와 단순한 제어문으로 가득



**큰 데이브 토마스 (OTI 창립자이자 이클립스 전략의 대부)**

- 깨끗한 코드는 **작성자가 아닌 사람도 읽기 쉽고 고치기 쉽다** => (가독성이라고 생각한다)
- **단위 테스트, 인수 테스트 케이스가 존재** => (testable한 코드)
- **의미 있는 이름**이 붙는다 => (네이밍의 중요성)
- 특정 목적을 달성하는 방법은 (여러 개가 아닌) **하나만 제공** 
- **의존성은 최소**이며, 각 의존성을 명확히 정의
- API는 명확하며 최소로 줄인다



**마이클 페더스 (Working Effectively with Legacy Code 저자)**

- 깨끗한 코드는 언제나 누군가 **주의 깊게 짰다**는 느낌을 준다
- 작성자가 이미 모든 사항을 고려했으므로, 고치려고하면 제자리로 돌아온다 (그만큼 주의를 기울여서 짠 코드라는 것)

주의 깊게 짰다는 것에서 동감한다. WWDC에서 예시로 들고나오는 코드들을 보다보면 정말 잘 작성되었다는 것을 종종 느끼곤한다..



**론 제프리스 (Extreme Programming Installed, Extreme Programming Adventure in C# 저자)**

- 모든 테스트 케이스를 통과한다
- **중복이 없다**
- 시스템 내 모든 설계 아이디어를 표현
- 클래스, 메서드, 함수 등을 최대한 줄인다
- 초반부터 간단한 추상화 고려하기

중복과 표현력만 신경 써도 (론 제프리스가 생각하는) 깨끗한 코드라는 목표에 성큼 다가갈 수 있다. `표현력` 이란 **의미 있는 이름**을 포함할 수 있고, 이 뿐만 아니라 여러 기능을 수행하는 객체나 메서드를 찾아 이를 여러 객체, 여러 메서드로 나누는 것과 같은 것도 포함된다. 

모든 프로그램이 아주 유사한 요소로 이뤄진다는 사실을 깨달았다. 예를 들어 '집합에서 항목 찾기'와 같이 프로그램 내에서 자주 필요한 경우 이를 추상 메서드나 추상 클래스를 만들어 실제 구현을 감싸서 구현한다. 이렇게 하여 '진짜' 문제에 신경 쓸 여유가 생기게 된다. 왜냐하면 실제 구현은 간단하게 해놓고 그때 그때 필요할 때 변경하면 되기 때문이다. 



**워닝 커닝햄** 

- 코드를 읽으면서 짐작했던 기능을 각 루틴이 그대로 수행한다면 깨끗한 코드
- 코드가 그 문제를 풀기 위한 언어처럼 보인다면 아름다운 코드



**책 저자**

- 깨끗한 변수 이름
- 깨끗한 함수
- 깨끗한 클래스

이를 작성하는 방법들을 앞으로 상세하게 설명할 것이다. 하지만 이들의 생각이 **절대적으로 '옳다'는 것은 아니므로 이를 단정하지 않도록 하자.**



## 보이스카우트 규칙

잘 짠 코드가 전부가 아니라, 시간이 흘러도 이를 잘 유지보수해야한다. 따라서 미국 보이스카우트가 따르는 간단한 규칙이 프로그래머들에게도 유용하다.

`캠프장은 처음 왔을 때보다 더 깨끗하게 해놓고 떠나라`

체크아웃할 때보다 **좀 더 깔끔한 코드를 체크인**한다면 코드는 절대 나빠지지 않는다. 





## 내가 생각하는 깨끗한 코드

그렇다면 내가 생각하는 깨끗한 코드란 무엇일까? 고민해 본 결과 아래의 4가지 정도 기준이 있을 것 같다. 

- 가독성이 좋아야한다 => 함수명, 변수명, 함수의 depth 등
- 클래스, 메서드는 하나의 역할만을 할 수 있게 작성하는 것이 좋다 => SOLID 중에서 SRP를 따를 수 있도록
- 확장을 고려해서 작성하자 => protocol, DI(Dependency Injection) 과 같은 방법을 사용해서 의존성을 낮추고 확장성을 키우자
- Unit test, Integration test가 가능해야한다 => testable한 코드

이외에도 여러 기준이 있을 수 있겠지만, 앞으로 클린코드 책을 읽으면서 위의 기준들을 더욱 상세하게 잡을 수 있도록 생각해보면서 읽어 볼 예정이다.  
